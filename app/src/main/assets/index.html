<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <link rel="stylesheet" href="css/ol.css" type="text/css">
    <link rel="stylesheet" href="css/style.css" type="text/css" >
    <script src="./build/ol.js"></script>
    <script src="scripts/utils.js"></script>
    <script src="scripts/geolocalisation.js"></script>
    <title>carte campus</title>
</head>
<body>
<div id="map" class="map"></div>
<div id="popup" class="ol-popup">
    <a href="#" id="popup-closer" class="ol-popup-closer"></a>
    <div id="popup-content"></div>
</div>
<div id="err" style="display: none;"></div>

</body>
</html>
<script type="text/javascript">
    //adresse du geoserver
    const addr = Android.getGeoServerIp();

    //recuperation des capabilities
    const caps = new ol.format.WMTSCapabilities().read(httpGet('http://'+ addr +':8080/geoserver/gwc/service/wmts?request=getcapabilities'));

    //on recupere les differents layers
    const batimentLayer = getVectorLayer(caps,'projetSIG:batimentsBis',batimentStyle);
    const natureLayer = getVectorLayer(caps,'projetSIG:nature',natureStyle);
    const routeLayer = getVectorLayer(caps,'projetSIG:voies',voieStyle);
    routeLayer.setMaxResolution(1/100000); // cache les route avant un certain niveau de zoom

    //on definit la map
    const map = new ol.Map({
        layers: [natureLayer, routeLayer, batimentLayer],
        target: 'map',
        view: new ol.View({
            projection: 'EPSG:4326',
            center: [1.9395,47.8438],
            zoom: 16,
            extent: [1.92377,47.83913,1.94151,47.84943]
        })
    });
    map.getView().setMinZoom(15);

    var userMarkers = new ol.source.Vector({ });

    var datas = JSON.parse(Android.getMarkersAsJson());
    var keyIndex = 0;

    for (var cursorMarker in datas)
    {
        var markerFeature = new ol.Feature({
            type: 'marker',
            geometry: new ol.geom.Point([datas[cursorMarker].lon, datas[cursorMarker].lat]),
            id : Object.keys(datas)[keyIndex],
            name : datas[cursorMarker].nom,
            tag : datas[cursorMarker].tag
        });
        keyIndex++;

        userMarkers.addFeature(markerFeature);
    }

    var markers = new ol.layer.Vector({
        source : userMarkers,
        style : markerStyle
    });

    map.addLayer(markers);

    //Composants du popupgetMarkersAsJson
    const container = document.getElementById('popup');//le pop-up
    const content = document.getElementById('popup-content');//le contenut du pop-up
    const closer = document.getElementById('popup-closer');//la croix qui ferme le pop-up

    //overlay pour positionner le popup
    const overlay = new ol.Overlay({
        element: container,
        autoPan: true,
        autoPanAnimation: {
            duration: 250
        }
    });
    map.addOverlay(overlay);

    //fonction pour fermer le popup
    closer.onclick = function() {
        overlay.setPosition(undefined);
        closer.blur();

        if (flagMarkerInInstance != 0)
        {
            userMarkers.removeFeature(marker);
            flagMarkerInInstance = 0;
        }

        return false;
    };

    function enregistrerMarker()
    {
        var markerName = document.getElementById("markerNom").value;
        var markerTagSelect = document.getElementById("markerTag");
        var markerTag = markerTagSelect.options[markerTagSelect.selectedIndex].value;

        if (markerName == "")
        {
            closer.onclick();
        }
        else
        {
            var markerCoords = marker.getGeometry().getCoordinates();
            Android.insertMarker(markerCoords[0], markerCoords[1], markerName, markerTag);

            flagMarkerInInstance = 0;
            closer.onclick();
        }

    }

    function deleteMarker(markerId)
    {
        Android.deleteMarkerWithId(markerId);

        var loadedMarkers = userMarkers.getFeatures();

        var index;
        var loadedMarker;
        for (index = 0; index < loadedMarkers.length; index++) {
            loadedMarker = loadedMarkers[index];

            if (loadedMarker.get("id") == markerId) {
                userMarkers.removeFeature(loadedMarker);
                closer.onclick();
                break;
            }
        }
    }

    const geolocation = addGeoloc(map);

    var searchVectorSource = new ol.source.Vector({ });
    search(searchVectorSource);
    var searchLayer = new ol.layer.Vector ({
         style : markerStyle,
         source : searchVectorSource,
         extent: [1.92377,47.83913,1.94151,47.84943]
    });
    map.addLayer(searchLayer);

    var marker;
    var flagMarkerInInstance = 0;

    map.on('singleclick', function(evt) {
        const feature = map.forEachFeatureAtPixel(evt.pixel, function (feature) {
            return feature;
        });

        if (flagMarkerInInstance != 0) {
            userMarkers.removeFeature(marker);
            flagMarkerInInstance = 0;
        }

        var touchCoordinates = evt.coordinate;
        marker = new ol.Feature({
            type: 'marker',
            geometry: new ol.geom.Point(touchCoordinates),
            id : Android.getMaxId()
        });

        const distance = distanceBetween(evt.coordinate,geolocation.getPosition());

        if (feature) {
            const feat = feature.properties_;
            if (feat) {
                if (feat.layer === 'batimentsBis') {
                    const name = feat.name;
                    content.innerHTML = '<p> nom: ' + name + '</p>'
                                        +'<p>coordonée: '+evt.coordinate+'</p>'
                                        +'<p>distance: '+distance+'</p>';
                    overlay.setPosition(evt.coordinate);
                }
                else {
                    flagMarkerInInstance = 1;
                    userMarkers.addFeature(marker);
                    showMarkerPopup(content, overlay, evt, Android.getTags());
                }
            }
            else {
                var featureType = feature.get("type");
                if (featureType == 'marker' || featureType == 'searchedMarker')
                {
                    var markerId = feature.get("id");

                    content.innerHTML = '<p> nom: ' + feature.get("name") + '</p>'
                                        +'<p>coordonée: '+evt.coordinate+'</p>'
                                        +'<p>distance: '+distance+'</p>';
                    if (featureType == 'marker') {
                        content.innerHTML += '<button onClick="deleteMarker(' + markerId + ')">Supprimer</button>';
                    }

                    overlay.setPosition(evt.coordinate);
                }
            }
        }
        else {
            flagMarkerInInstance = 1;
            userMarkers.addFeature(marker);
            showMarkerPopup(content, overlay, evt, Android.getTags());
        }
    });
</script>
